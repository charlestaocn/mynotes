
# 元表

[Lua 元表(Metatable) | 菜鸟教程 (runoob.com)](https://www.runoob.com/lua/lua-metatables.html)
## 使用

```lua

mytable = setmetatable({key1 = "value1"}, {  
  __index = function(mytable, key)  
    if key == "key2" then  
      return "metatablevalue"  
    else  
      return nil  
    end  
  end  
})  
  
print(mytable.key1,mytable.key2)


value1    metatablevalue


============================
mytable = setmetatable(  
        { key1 = "value1" },  
        { __index = { key2 = "metatablevalue" } }  
)  
print(mytable.key1, mytable.key2)

```


- mytable 表赋值为 **{key1 = "value1"}**。
    
- mytable 设置了元表，元方法为 __index。
    
- 在mytable表中查找 key1，如果找到，返回该元素，找不到则继续。
    
- 在mytable表中查找 key2，如果找到，返回 metatablevalue，找不到则继续。
    
- 判断元表有没有__index方法，如果__index方法是一个函数，则调用该函数。
    
- 元方法中查看是否传入 "key2" 键的参数（mytable.key2已设置），如果传入 "key2" 参数返回 "metatablevalue"，否则返回 mytable 对应的键值。

## 总结

Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:

- 1.在表中查找，如果找到，返回该元素，找不到则继续
- 2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。
- 3.判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。

## 往元表中添加

>当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作。


```lua
mymetatable = {}  
mytable = setmetatable({key1 = "value1"}, { __newindex = mymetatable })  
  
print(mytable.key1)  
  
mytable.newkey = "新值2"  
print(mytable.newkey,mymetatable.newkey)  
  
mytable.key1 = "新值1"  
print(mytable.key1,mymetatable.key1)


value1
nil    新值2
新值1    nil
```


>在对新索引键（newkey）赋值时（mytable.newkey = "新值2"），会调用元方法，而不进行赋值。而如果对已存在的索引键（key1），则会进行赋值，而不调用元方法 __newindex。


以下实例使用了 rawset (不触发元方法) 函数来更新表：

```lua

mytable = setmetatable({key1 = "value1"}, {  
    __newindex = function(mytable, key, value)  
        rawset(mytable, key, "\""..value.."\"")  
    end  
})  
  
mytable.key1 = "new value"  
mytable.key2 = 4  
  
print(mytable.key1,mytable.key2)

new value    "4"
```