#### 1. 二叉树的由来

在 jdk1.8 之前，HashMap 的数据结构由「数组+链表」组成，数组是 HashMap 的主体，链表是为了解决 Hash 冲突引入的，正常的数据存放是直接存在数组中，但如果发生 Hash 冲突就会以链表的形式进行存储，而在 jdk1.8之后，当链表的长度超过 8 之后，将会转换成红黑树经常存储...

相信这一段 HashMap 的描述，一定是大家所熟知的，其实细品之后，我们可以从这段描述中发掘这些信息。

`数组` **>** `链表` **>** `树`。

正所谓有需求就会有发展，我们来看看为什么在有「数组+链表」的情况下，还出来个树结构。

###### 数组优点：

- 简单易用，随机访问性强
- 无序数组插入速度很快，效率为O1
- 有序数组查找速度较快，效率为O(logN)

###### 数组缺点：

- 插入和删除效率低
- 数组大小固定，无法动态扩容

###### 链表优点：

- 大小不固定，无限扩容
- 插入和删除速度很快

###### 链表缺点：

- 查询效率低，不支持随机查找，必须从第一个开始遍历
- 在链表非表头的位置进行插入、删除很慢，效率为O(N)

从数组到链表的优缺点，我们可以看出是各有千秋，不能很准确的说链表比数组就一定要高效，而正是因为这种关系的存在，所以二叉树出现了。

所以二叉树的由来：二叉树整合了数组和链表的优缺点，使得插入、删除、查找的速度都很快，效率比较高。

#### 2. 二叉树是什么

二叉树是树形结构的一个重要类型，也是众多数据结构的基石。

树有很多类型，每个节点最多只能有两个子节点的叫二叉树。

所以，二叉树的特性就是每个节点的子结点不允许超过两个。

![[someting/_resources/链结构-树/83e36b91e28d423cbdda3e19374a8a47_MD5.png]]

#### 3. 二叉查找树

二叉查找树是一种特殊的二叉树，二叉查找树的特点就是，左子树节点比父节点小，右子树节点值比父节点大。

![[someting/_resources/链结构-树/c7c036b8a4a2527e564849330992ff61_MD5.png]]

###### 极端现象

二叉查找树有一种极端的存在，二叉树的大部分子节点都比父节点值小，然后导致所有的数据偏向左侧，进而退化成链表，如下图所示：

![[someting/_resources/链结构-树/03db272168955bc90002185e2a7ec4f4_MD5.png]]

我们使用二叉树的目的是因为其效率高于链表查询，但这种退化为链表的现象很显然就突兀，怎么办呢。

所以为了解决二叉树退化成一棵链表就引入了平衡二叉树。

#### 4. 平衡二叉树(avl数)

平衡二叉树，又被称为AVL树，是为了解决二叉树退化成一棵链表而诞生的。

平衡二叉树特点：

- 拥有二叉查找树的全部特性。
- 每个节点的左子树和右子树的高度差至多等于1。

其中左右子树的高度差是通过左旋右旋实现的。

下面是一个平衡二叉树和非平衡二叉树的图：

![[someting/_resources/链结构-树/62d2a6d833b668acceefaa05b2e16476_MD5.png]]

到底是如何判断高度差的呢？我们可以来数节点最长连接数，比如左侧节点最长连接数为「3 > 4 > 5」3个节点，右侧为「9」一个节点，所以高度差为2。

再比如下面一个平衡二叉树：

![[someting/_resources/链结构-树/6619ff6f90495f1707095c62ebc2433c_MD5.png]]

左侧最长连接点为「3(9) > 7 >11」，即高度为2，右侧最长连接点为「14(16) > 15 > 18 > 11」，即高度为4，所以高度差为2。

为了维持二叉树的平衡，平衡二叉树是通过左旋、右旋来保证的，从大的方向旋转过程又被分为单旋转和双旋转；

但是平衡二叉树这种高度差为 1 的要求太严格了，尤其是对于频繁删除、插入的场景非常浪费时间...


#### 有序链左旋右旋

[[someting/_resources/链结构-树/c28a18f1c2301ada1920c6d7bf18282c_MD5.jpeg|Open: 左右旋.png]]
![[someting/_resources/链结构-树/c28a18f1c2301ada1920c6d7bf18282c_MD5.jpeg]]

**c节点左旋**：选中要左旋c的节点向左偏，由右节点d顶替，将d节点的e节点及子树直接分给c节点 ==( e节点及子树必定比c节点要大 所以可以直接给c节点 )==

**d节点右旋**：选中要右旋d的节点向右偏，由左节点c顶替，将c节点的e节点及子树直接分给d节点 ==( e节点及子树必定比d节点要小 所以可以直接给d节点 )


> LL & LR => LL 左旋
> RR & RL => RR 右旋 

####  5. 红黑树 
#readblacktree
<a name="redblacktee"></a>
对于那种频繁删除、插入的场景，平衡二叉树的调整过程显然是存在性能问题的，所以为了解决这个问题，进而又引入了红黑树。

红黑树的特点：

- 具有二叉树所有特点。
- 每个节点只能是红色或者是黑色。
- 根节点只能是黑色，且黑色根节点不存储数据。
- 任何相邻的节点都不能同时为红色。
- 红色的节点，它的子节点只能是黑色。
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

路径最长的为红黑相间的，
路径最短的为全黑的

平衡判断是 路径相差不超过2倍
 左 红的 + 黑的 
 右 黑的
 因为左右黑的数目相同，而且红黑是相间的，所以最多的平衡点路径差不超过2倍


红黑树如下图所示：

![[someting/_resources/链结构-树/ca41b2c3f93ba8bcc1c34a7e470e88fc_MD5.png]]

概括为：红黑树所有的根节点都是黑色的的空节点，也就是根节点不存数据；任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开的，每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。

正是因为这种特点，红黑树不同于平衡树的操作，红黑树不会因为插入、删除等操作追求绝对的平衡，它的旋转次数少，插入最多两次旋转，删除最多三次旋转，所以对于搜索、插入、删除操作较多的情况下，红黑树的效率是优于平衡二叉树的。

但是需要注意的是，如果应用场景中对插入、删除不频繁，只是对查找要求较高，那么平衡二叉树还是较优于红黑树。

##   四、B树(B-Tree)

  
**(1)概念：**  
B树和平衡二叉树不同，B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引里大量使用者B-Tree和B+Tree的数据结构。  
**(2)特点：**

- （1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
- （2）子节点数：非叶节点的子节点数>1，且<=M  
    ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路，当M=2则是2叉树,M=3则是3叉）；
- （3）关键字数：枝节点的关键字数量大于等于ceil(M/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数  
    如ceil(1.1)结果为2);
- （4）所有叶子节点均在同一层、叶子节点除了包含了关键字还包含了数据;

最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C>B>A）  

![[someting/_resources/链结构-树/72bf0a27c0eeba657a77ba3db6255fde_MD5.webp]]

  
图中可以看到BTree的单个节点可以存储多个键值和数据的平衡树。和平衡二叉树相比：  
比如要存储海量的数据，因为（平衡）二叉树的每个节点只存储一个键值和数据的，二叉树的节点将会非常多，高度也会及其高，当查找数据时也会进行很多次磁盘IO，查找的效率将会极低，大致的二叉树结构如下：  

![[someting/_resources/链结构-树/9cc5279eddc70bf60d3de3181ae8c7e2_MD5.webp]]

  
**为了解决平衡二叉树的这个弊端，需要一种单个节点可以存储多个键值和数据的平衡树（BTree）：**  

![[someting/_resources/链结构-树/68fb7bc5023bb11b5a7093c6540d6706_MD5.webp]]

  
从上图可以看出，B树相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点，子节点的个数一般称为阶，**上述图中的B树为3阶B树，高度也会很低**。 基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。  
**假如我们要查找id=28的用户信息，那么我们在上图B树中查找的流程如下：**  

1. 先找到根节点也就是页1，判断28在键值17和35之间，我们那么我们根据页1中的指针p2找到页3。
2. 将28和页3中的键值相比较，28在26和30之间，我们根据页3中的指针p2找到页8。
3. 将28和页8中的键值相比较，发现有匹配的键值28，键值28对应的用户信息为(28,bv)。

区别：B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。  
相同数量的key在B-Tree中生成的节点要远远少于二叉树中的节点，相差的节点数量就等同于磁盘IO的次数。这样到达一定数量后，性能的差异就显现出来了。

##   五、B+树（B+Tree）

  
**(1)概念**  
B+树是B树的一个进化，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。结构如下：  

![[someting/_resources/链结构-树/55a6523300d3351e333727349b7860a1_MD5.webp]]

  
为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别：  
**1.B+树的非叶子节点不保存数据，只进行数据索引（关键字记录的指针），这样使得B+树每个非叶子节点所能保存的关键字大大增加；**  
**2.B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；**  
**3.B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针；**  
**4.B+树非叶子节点的子节点数=关键字数;**  
**(2)特点:**  
1、B+树的层级更少：相较于B树，B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；  
2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;  
3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。  
4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。  
B树相对于B+树的优点是：如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。  
**根据上图我们来看下B+树和B树有什么不同：**  

1. B+Tree 非叶子节点上是不存储数据的，仅存储键值，数据存储在同一层的叶节点，而B-Tree节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数(节点的子节点树)就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。另外，B+Tree的阶数是等于键值的数量的，如果B+Tree一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。
2. 因为B+Tree索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B-Tree 因为数据分散在各个节点，要实现这一点是很不容易的。

B+Tree 中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。  
其实上面的B-Tree也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在mysql的innodb存储引擎中，索引就是这样存储的。也就是说上图中的B+Tree索引就是innodb中B+Tree索引真正的实现方式，准确的说应该是聚集索引。  
通过上图可以看到，在innodb中，数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。  
注意：MyISAM中的B+树索引实现与innodb中的略有不同。在MyISAM中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。

##   六、总结

  
B+Tree 结构是从二叉查找树，平衡二叉树和B-Tree这三种数据结构演化来的，他们之前的区别上面已经介绍过，现在大致的总结下，如下：  
1，二叉查找树是基于二分查找法来提高数据查找速度的二叉树的数据结构，减少无关数据的检索，提升了数据检索的速度。非叶子节点只能允许最多两个子节点存在，每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值，每个节点只存储一个键值和数据的。  
2，平衡二叉树满足二叉查找树特性的基础上，如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。  
3，B-TreeB和平衡二叉树不同，B-Tree属于多叉树又名平衡多路查找树， B-Tree相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点。  
4，B+Tree和B-Tree不同，B+Tree在非叶子节点上，不保存数据，只存储指针，能存储更多的键值，相应的树的阶数(节点的子节点树)就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。并且B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。


### **为什么有了数组和链表还要引入二叉树？**

针对数组和链表的优缺点，无法说链表一定优于数组，或者是数组一定优于链表，因为某些长期的需要，所以就推出一个相对折中的二叉树。

### **为什么有了二叉树还要引入平衡二叉树？**

有了二叉树还不算完，二叉树有一种极端的情况，就是所有的子结点偏向一端，二叉树退化成链表，这就相当于我选择了这种的二叉树，你现在罢工不干了，找了个链表来糊弄我...

所以为了解决二叉查找树退化为链表的情况，引入了平衡二叉树，即：

平衡二叉树是为了解决二叉树退化成一棵链表而诞生的。

既然有了平衡二叉树，这下总没有问题了吧？

### **为什么有了平衡二叉树还要引入红黑树？**

但是是实际使用过程中，因为平衡二叉树追求绝对严格的平衡关系，显然这个规则在于频繁的插入、删除等操作的情景性能肯定会出现问题...

所以为了解决这个问题，进而又引入了红黑树。

平衡二叉树追求绝对严格的平衡，平衡条件必须满足左右子树高度差不超过1，红黑树是放弃追求完全平衡，它的旋转次数少，插入最多两次旋转，删除最多三次旋转，所以对于搜索、插入、删除操作较多的情况下，红黑树的效率是优于平衡二叉树的。

### **红黑树是终结吗？**

时代总是进步的，大胆猜测不会是，就跟当初从数组、链表到二叉树一样。

至此，通过这篇希望大家对整个树结构的出现有一个基础的概念，目前面试中最为常问的就是红黑树了，当然这得益于 HashMap，但红黑树还有挺多其他的知识点可以考察，例如红黑树有哪些应用场景？红黑树与哈希表在不同应该场景的选择？红黑树有哪些性质？红黑树各种操作(插入删除查询)的时间复杂度是多少？等等等等...
