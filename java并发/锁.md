## 乐观锁 和悲观锁

### 悲观锁（抽象性，不真实存在这个锁）

==使用资源时锁资源，一个人用了其他的需要等待释放或者直接返回失败==

就是很悲观，每次去取数据的时候都认为别人会去修改，所以每次在取数据的时候都会给它上锁，这样别人想拿这个数据就会block直到它取到锁。比如用在库存增减问题上，利用悲观锁可以有效的防止减库存问题。
  
简单来讲，悲观锁就是假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。悲观并发控制实际上是 “先取锁，再访问” 的保守策略，为数据处理的安全提供了保证。
  
在效率上，处理加锁的机制会让数据库产生额外的开销，还会有死锁的可能性。降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。、

##### 悲观锁的实现方式

悲观锁的实现，依靠数据库提供的锁机制。  

在数据库中，悲观锁的流程如下：  
1.  在对数据修改前，尝试增加排他锁。  
2.  加锁失败，意味着数据正在被修改，进行等待或者抛出异常。  
3.  加锁成功，对数据进行修改，提交事务，锁释放。  
4.  如果我们加锁成功，有其他线程对该数据进行操作或者加排他锁的操作，只能等待或者抛出异常。

### 乐观锁 （抽象性，不真实存在这个锁）

==使用资源时不锁资源，大家可以一起用==

##### 乐观锁的实现方式

1. version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

```sql
update table set n=n+1, version=version+1 where id=#{id} and version=#{version};
```


2. CAS操作方式：即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。

###  优缺点  

两种锁各有优缺点，不可认为一种好于另一种，比如像乐观锁，适用于写比较少的情况下，冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。


## 公平锁和非公平锁

 #### 公平锁
 
 >每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的，最前面的线程总是最先获取到锁。
#### 非公平锁

>每个线程获取锁的顺序是随机的，并不会遵循先来先得的规则，所有线程会竞争获取锁。


举个例子，公平锁就像开车经过收费站一样，所有的车都会排队等待通过，先来的车先通过，如下图所示：

![[_resources/锁/e04adbab8154aba272338bc6b591e30b_MD5.webp]]

通过收费站的顺序也是先来先到，分别是张三、李四、王五，这种情况就是公平锁。 而非公平锁相当于，来了一个强行加塞的老司机，它不会准守排队规则，来了之后就会试图强行加塞，如果加塞成功就顺利通过，当然也有可能加塞失败，如果失败就乖乖去后面排队，这种情况就是非公平锁。 ![[_resources/锁/7f02868dd99cbe8528e7990fcf44ca45_MD5.webp]]

### 应用场景

**在 Java 语言中，锁 synchronized 和 ReentrantLock 默认都是非公平锁，当然我们在创建 ReentrantLock 时，可以手动指定其为公平锁，但 synchronized 只能为非公平锁。** ReentrantLock 默认为非公平锁可以在它的源码实现中得到验证，如下源码所示： ![[_resources/锁/d53ab461941db3d19a790749d91d211a_MD5.webp]]当使用 new ReentrantLock(true) 时，可以创建公平锁，如下源码所示： ![[_resources/锁/42f895e8614994142c079371d87894dc_MD5.webp]]

### 公平和非公平锁代码演示

#### 公平锁

接下来我们使用 ReentrantLock 来演示一下公平锁和非公平锁的执行差异，首先定义一个公平锁，开启 3 个线程，每个线程执行两次加锁和释放锁并打印线程名的操作，如下代码所示：

```java
import java.util.concurrent.locks.Lock;  
import java.util.concurrent.locks.ReentrantLock;  
  
public class ReentrantLockFairTest {  
    static Lock lock = new ReentrantLock(true);  
  
    public static void main(String[] args) throws InterruptedException {  
        for (int i = 0; i < 3; i++) {  
            new Thread(() -> {  
                for (int j = 0; j < 2; j++) {  
                    lock.lock();  
                    System.out.println("当前线程：" + Thread.currentThread().getName());  
                    lock.unlock();  
                }  
            }).start();  
        }  
    }  
}

```

以上程序的执行结果如下图所示： ![[_resources/锁/d2134706b8f8464b51154812c324ce0d_MD5.webp]]
#### 非公平锁

接下来我们使用非公平锁来执行上面的代码，具体实现如下：

```java 
import java.util.concurrent.locks.Lock;  
import java.util.concurrent.locks.ReentrantLock;  
  
public class ReentrantLockFairTest {  
    static Lock lock = new ReentrantLock();  
    public static void main(String[] args) throws InterruptedException {  
        for (int i = 0; i < 3; i++) {  
            new Thread(() -> {  
                for (int j = 0; j < 2; j++) {  
                    lock.lock();  
                    System.out.println("当前线程：" + Thread.currentThread()  
                            .getName());  
                    lock.unlock();  
                }  
            }).start();  
        }  
    }  
}
```

以上程序的执行结果如下图所示： ![[_resources/锁/e51f7ff22752784aec411b66f0b638bb_MD5.webp]]从上述结果可以看出，使用公平锁线程获取锁的顺序是：A -> B -> C -> A -> B -> C，也就是按顺序获取锁。而非公平锁，获取锁的顺序是 A -> A -> B -> B -> C -> C，原因是所有线程都争抢锁时，因为当前执行线程处于活跃状态，其他线程属于等待状态（还需要被唤醒），所以当前线程总是会先获取到锁，所以最终获取锁的顺序是：A -> A -> B -> B -> C -> C。

### 执行流程分析

#### 公平锁执行流程

获取锁时，先将线程自己添加到等待队列的队尾并休眠，当某线程用完锁之后，会去唤醒等待队列中队首的线程尝试去获取锁，锁的使用顺序也就是队列中的先后顺序，在整个过程中，线程会从运行状态切换到休眠状态，再从休眠状态恢复成运行状态，但线程每次休眠和恢复都需要从用户态转换成内核态，而这个状态的转换是比较慢的，所以公平锁的执行速度会比较慢。

#### 非公平锁执行流程

当线程获取锁时，会先通过 CAS 尝试获取锁，如果获取成功就直接拥有锁，如果获取锁失败才会进入等待队列，等待下次尝试获取锁。这样做的好处是，获取锁不用遵循先到先得的规则，从而避免了线程休眠和恢复的操作，这样就加速了程序的执行效率。 公平锁和非公平锁的性能测试结果如下，以下测试数据来自于《Java并发编程实战》：

#### 性能比较
![[_resources/锁/7a2f6e71a1c7ed02442f3b9ae72b5434_MD5.webp]]从上述结果可以看出，使用非公平锁的吞吐率（单位时间内成功获取锁的平均速率）要比公平锁高很多。

### 优缺点分析

公平锁的优点是按序平均分配锁资源，不会出现线程饿死的情况，它的缺点是按序唤醒线程的开销大，执行性能不高。 非公平锁的优点是执行效率高，谁先获取到锁，锁就属于谁，不会“按资排辈”以及顺序唤醒，但缺点是资源分配随机性强，可能会出现线程饿死的情况。

### 总结

在 Java 语言中，锁的默认实现都是非公平锁，原因是非公平锁的效率更高，使用 ReentrantLock 可以手动指定其为公平锁。非公平锁注重的是性能，而公平锁注重的是锁资源的平均分配，所以我们要选择合适的场景来应用二者。


## mysql 共享锁与排他锁
### 共享锁

对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源（也可以再继续加共享锁，即 共享锁可多个共存），但无法修改。要想修改就必须等所有共享锁都释放完之后。语法为：

```sql
select * from table lock in share mode
```

### 排他锁 （悲观锁一种实现）

排他锁：对某一资源加排他锁，自身可以进行增删改查，其他人无法进行任何操作。语法为：==增删改自动加了排他锁==
```sql
select * from table for update 
```



## 可重入锁和不可重入锁

### 可重入锁

==同线程==的锁资源可被重入 :  ==可防止死锁==

```java

public static void main(String[] args) throws InterruptedException {  
    testReLockA();  
}  
  
public static void testReLockA() throws InterruptedException {  
    synchronized (i) {  
        System.out.println("A!!!!");  
    }  
    Thread.sleep(10000);  
}  
  
public static void testReLockB() {  
	//同一个main线程的 sync(i) 这里不会锁住，正常进入，防止死锁
    synchronized (i) { 
        System.out.println("B!!!!");  
    }  
}


=>>>>>
A!!!!
B!!!!

```

==不同线程时==


```java
public static void main(String[] args) throws InterruptedException {  
    testReLockA();  
}  
  
public static void testReLockA() throws InterruptedException {  
    synchronized (i) {  
        System.out.println("A!!!!");  
        //开新线程调用
        new Thread(() -> testReLockB());  
    }  
    Thread.sleep(10000);  
}  
  
public static void testReLockB() { 
	//不是同一个main线程的 sync(i) 这里会被锁住
    synchronized (i) {  
        System.out.println("B!!!!");  
    }  
}

=>>>>>
A!!!!
//
```

### 不可重入锁

- **我们自己可以用synchronized + wait + notify来实现不可重入锁，代码如下：**

![[_resources/锁/8bfedbcf9ecae71f25b3046627187fac_MD5.webp]]