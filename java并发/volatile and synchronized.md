## volatile

 ### 防指令重排
 
> 在volatile修饰的属性读写操作前后加读写屏障 防止下面或者上面的的指令与当前指令排序


 ![[452b08eff668f7c4adaf03a8b4bf2e39_MD5.png]]
 ![[7436ff1ab7617556f60c932645be6053_MD5.png]]
 ### 可见性

> 多线程修改一个共享属性时后面的线程察觉不到前面线程修改后的值  =》添加 volatile解决

mesi协议并不是无条件生效的，==需要Java语言层面上的volatile去触发CPU层面上的缓存一致性协议==。根据MESI,线程1的L1缓存行中变量user是M修改，E独占，S共享的时候，消息总线嗅探到线程2对L1缓存行中变量user执行了写操作，此时线程1中该缓存行会置为I无效，之后在线程1对该user进行读操作时，发现是I无效状态，就会去系统内存中同步最新的值。

可以发现volatile是通过触发CPU的缓存一致性协议来实现可见性的，那么volatile是如何出触发CPU的缓存一致性协议呢？
当User被volatile修饰后，转译为汇编代码后会多出一条Lock前缀的指令
![[8e7e43c86887cff571fc11647f352c42_MD5.png]]
IA-32架构软件开发者手册可知，Lock前缀的指令在多核CPU下会触发两件事

将当前处理器缓存行的数据写回到系统内核。
当线程2对user进行更改时，即对L1缓存行进行更改，此时L1缓存行写回到L2->L3->系统内存。Lock前缀会锁定线程2的L1缓存行并写回内存，使用缓存一致性机制来确保修改的原子性，该操作为"缓存锁定"。
将这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。
当线程2的缓存写回到系统内存，线程1使用嗅探得知线程2打算把缓存写回内存，而该缓存又为共享变量，使用volatile触发了缓存一致性机制，那么此时正在嗅探的线程2使他的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充，即将缓存行读取从系统内存->L3->L2->L1。

### [Synchronized](../Synchronized.html)

==调用了 对象自己的hashcode方法(非自己实现的) 会使无锁状态 跳过 偏向锁 直接进入 轻量锁 因为 偏向锁 的 偏向线程id 和epoch 会占用 hashcode 的位置  所以 需要使用 hashcode 方法时 最好自己重写一下==

![[b4f06aa9844b9b137425c07c4a7db700_MD5.png]]

==jdk 15 开始去除了偏向锁==