
## 1. 背景

### 1.1 概念和应用场景

延迟消息（定时消息）即消息到达消息队列服务端后不会马上投递，而是到达某个时间才投递给消费者。它在在当前的互联网环境中有非常大的需求。

例如电商/网约车等业务中都会出现的订单场景，客户下单后并不会马上付款，但是这个订单也不可能一直开着，因为订单会占用商品/网约车资源。这时候就需要一个机制，在比如 5 分钟后进行一次回调，回调关闭订单的方法。 这个回调的触发可以用分布式定时任务来处理，，但是更好的方法可以是使用消息队列发送一个延迟消息，因为一条消息会比一个分布式定时任务轻量得多。 开启一个消费者消费订单取消 Topic 的消息，收到消息后关闭订单，简单高效。

当用户支付了订单，那么这个订单不再需要被取消，刚才发的延迟消息也不再需要被投递。当然，你可以在消费消息时判断一下订单的状态以确定是否需要关闭，但是这样做会有一次额外的数据库操作。如果可以取消定时消息，那么只要发送一条定时消息取消的命令就可以取消之前发送的定时消息投递。

除此之外，定时消息还能用于更多其他场景，如定时任务触发、等待重试、事件预订等等。

### 1.2 延迟消息与定时消息

首先需要明确延迟消息与定时消息虽然意思不同，但在体现的效果上确实相同的，都是在消息生产到 Broker 之一段时间之后才会被投递（消费者可以消费到）。只不过在使用的 API 上，延迟消息指定延迟的时间，而定时消息指定确切的投递时间。实际上它们可以实现相同的效果。

在 Rocketmq 4.x 中只支持通过设定延迟等级来支持 18 个固定延迟时间。具体的原理可以看 [RocketMQ 延迟消息（定时消息）源码解析](https://link.zhihu.com/?target=https%3A//github.com/HScarb/knowledge/blob/master/rocketmq/20220313-rocketmq-scheduled-message.md)。

4.x 的延迟消息有很大的局限性，它无法支持任意时间的定时，而且最大的定时时间也只有 2 小时，它的性能也达不到普通消息（后来 4.x 的延迟消息性能被优化，详见 [RocketMQ 延迟消息（定时消息）4.9.3 版本优化 异步投递支持](https://link.zhihu.com/?target=https%3A//github.com/HScarb/knowledge/blob/master/rocketmq/20220320-rocketmq-scheduled-message-4.9.3-improve.md)。

许多公司不满足于它的能力，自研了任意时间定时消息，扩展了最大定时时长。

在 Rocketmq 5.x 中终于开源了支持任意时间的定时消息（以下简称定时消息）。它与 4.x 的延迟消息是两套实现机制，互相之间几乎不影响。

### 1.2 任意时间定时消息的使用

在 Rocketmq 5.x 的客户端中，在构造消息时提供了 3 个 API 来指定延迟时间或定时时间。

```text
Message message = new Message(TOPIC, ("Hello scheduled message " + i).getBytes(StandardCharsets.UTF_8));
// 延迟 10s 后投递
message.setDelayTimeSec(10);
// 延迟 10000ms 后投递
message.setDelayTimeMs(10_000L);
// 定时投递，定时时间为当前时间 + 10000ms
message.setDeliverTimeMs(System.currentTimeMillis() + 10_000L);
// 发送消息
SendResult result = producer.send(message);
```

## 2. 概要设计

### 2.1 任意时间定时消息的难点

任意时间定时消息的实现存在一定的难点，所以 4.x 才会实现 18 个延迟等级的定时消息，作为一个折衷的方案。

任意时间定时消息的主要难点有以下几个。

#### 2.1.1 难点1：任意的定时时间

Rocketmq 4.x 的延迟消息的原理简单来说是：将延迟消息先不存到真正的 Topic，先存到一个延迟 Topic，然后周期性扫描这个 Topic 还未投递的消息是否到期，到期则投递到真正的 Topic 中。

这个方案的局限性在于扫描的每个队列的消息延迟时间必须是相同的。否则会出现先扫描的消息要后投递的情况，如下图所示：


![[b152a2cad8408013d23dfec8926e0ae3_MD5.png]]

队列中的第一个消息延迟 100s，从队列头开始扫描，需要等待第一个消息先投递，从队列中弹出，后面的消息才能投递。所以第一条消息会**阻塞**后续消息的投递。

为了避免这个问题，Rocketmq 4.x 的延迟 Topic 中包含 18 个队列，每个队列代表一个延迟等级，对应一个**固定的延迟时长**，用一个周期性任务去扫描。

但任意时间定时消息不可能无限制地增加延迟时长对应的队列数量，这是一个难点。

#### 2.1.2 难点2：定时消息的存储和老化

我们知道 Rocketmq 的消息是有老化时间的，默认时间为 3 天。这就意味着延迟时间超过 3 天的消息可能会被老化清除，永远无法投递。

让定时消息不受老化时间的限制，这也是一个难点。

#### 2.1.3 难点3：大量定时消息的极端情况

在定时消息场景下有一种极端情况，就是在同一时刻定时了超大量的消息，需要在一瞬间投递（比如在 8 点定时了 1 亿条消息）。

如果不进行流控直接写入，会把 Rocketmq 冲垮。

### 2.2 设计思路

#### 2.2.1 任意时间定时

实现任意时间的定时的要点在于知道在某一时刻需要投递哪些消息，以及破除一个队列只能保存同一个延迟等级的消息的限制。

联想 Rocketmq 的索引文件 `IndexFile`，可以通过索引文件来辅助定时消息的查询。需要建立这样的一个索引结构：Key 是时间戳，Value 表示这个时间要投递的所有定时消息。类似如下的结构：

```text
Map<Long /* 投递时间戳 */, List<Message /* 被定时的消息 */>>
```

把这个索引结构以文件的形式实现，其中的 `Message` 可以仅保存消息的存储位置，投递的时候再查出来。

---

RIP-43 中就引入了这样的两个存储文件：`TimerWheel` 和 `TimerLog`，存储结构如下图所示：

![[rocketmq/_resources/延迟消费/ab9cefd572a0502af9d40df557448a79_MD5.png#pic_center]]

`TimerWheel` 是时间轮的抽象，表示投递时间，它保存了 2 天（默认）内的所有时间窗。每个槽位表示一个对应的投递时间窗，并且可以调整槽位对应的时间窗长度来控制定时的精确度。

采用时间轮的好处是它可以复用，在 2 天之后无需新建时间轮文件，而是只要将当前的时间轮直接覆盖即可。

`TimerLog` 是定时消息文件，保存定时消息的索引（在`CommitLog` 中存储的位置）。它的存储结构类似 `CommitLog`，是 Append-only Log。

`TimerWheel` 中的每个槽位都可以保存一个指向 `TimerLog` 中某个元素的索引，`TimerLog` 中的元素又保存它前一个元素的索引。也就是说，`TimerLog` 呈链表结构，存储着 `TimerWheel` 对应槽位时间窗所要投递的所有定时消息。

#### 2.2.2 定时消息轮转：避免定时消息被老化删除

为了防止定时消息在投递之前就被老化删除，能想到的办法主要是两个：

1. 用单独的文件存储，不受 Rocketmq 老化时间限制
2. 在定时消息被老化之前，重新将他放入 `CommitLog`

方法 1 需要引入新的存储文件，占用磁盘空间；方法 2 则需要在消息被老化前重新将其放入 `CommitLog`，增加了处理逻辑的复杂性。

RIP-43 中选择了第二种方案，在定时消息**放入时间轮前**进行判断，如果在 2 天内要投递（在时间轮的时间窗口之内），则放入时间轮，否则重新放入 `CommitLog` 进行轮转。

#### 2.2.3 定时任务划分和解耦

RIP-43 中，将定时消息的保存和投递分为多个步骤。为每个步骤单独定义了一个服务线程来处理。

保存：

1. 从定时消息 Topic 中扫描定时消息
2. 将定时消息（偏移量）放入 `TimerLog` 和 `TimeWheel` 保存

投递：

1. 从时间轮中扫描到期的定时消息（偏移量）
2. 根据定时消息偏移量，到 `CommitLog` 中查询完整的消息体
3. 将查到的消息投递到 `CommitLog` 的目标 Topic

每两个步骤之间都使用了生产-消费模式，用一个有界的 `BlockingQueue` 作为任务的缓冲区，通过缓冲区实现每个步骤的流量控制。当队列满时，新的任务需要等待，无法直接执行。

## 3. 详细设计

### 3.1 定时消息文件设计

RIP-43 中引入了两个采用本地文件系统存储的文件：`TimerWheel` 和 `TimerLog`

#### 3.1.1 `TimerWheel` 时间轮

时间轮是对时刻表的抽象，内部实际上是一个数组，表示一段时间。每项都是一个槽位，表示时刻表上的每一秒。采用时间轮的好处在于它可以循环使用，在时间轮表示的这段时间过去之后，无需创建新的文件，直接可以表示下一段时间。

时间轮的每个槽位表示这一时刻需要投递的所有定时消息，槽位中保存了指向 `TimerLog` 的指针，与 `TimerLog` 一同构成一个链表，表示这组消息。

时间轮的槽位设计如下：

- `first_pos`：TimerLog 中该时刻定时消息链表的第一个消息的物理偏移量（链表尾）
    
- `last_pos`：TimerLog 中该时刻定时消息链表的最后（最新）一个消息的物理偏移量（链表头）
    

#### 3.1.2 `TimerLog` 定时消息索引文件

`TimerLog` 与 `TimerWheel` 配合，一起表示某一时刻需要投递的定时消息集合。

它的形式是与 `CommitLog` 相似的 Append-only Log，不过每一项不需要保存消息的全量信息，只保存了消息在 `CommitLog` 上的物理偏移量，节省空间。

它与 `TimerWheel` 中的槽位组成链表结构，所以它的每一项也有一个指向该项上一项的指针。

它的每一项结构如下：

### 3.2 定时消息投递步骤

定时消息主要的逻辑可以分为**保存**和**投递**两个阶段，RIP-43 将每个节点都拆分成不同的任务（服务线程），用生产-消费模式衔接每个任务，实现任务的解耦和流控。
![[delay-msg.png]]
如上图所示，带有 `enqueue` 的为定时消息保存的线程和队列，带有 `dequeue` 的为定时消息投递的线程和队列。

#### 3.2.1 定时消息保存

定时消息在被保存到 `CommitLog` 前，会检查其的属性，如果消息属性中包含定时属性，则会将真正要投递的 Topic 暂存到消息属性中，把投递的 Topic 改成 `rmq_sys_wheel_timer`。

随后等待服务线程扫描这个定时 Topic 中的消息，放入时间轮，开始定时。

为了避免瞬时保存的定时消息过多，所以采用了生产-消费模式，将保存的过程分为扫描和入轮两个步骤。

`TimerEnqueueGetService` 扫描定时消息

这个线程通过遍历消费队列索引的方式不断扫描定时消息 Topic 中新的定时消息。

扫描到了之后将消息从 `CommitLog` 中查出来，封装成 `TimerRequest`，放入有界阻塞队列 `enqueuePutQueue`。如果队列满，则会无限次重试等待，达到流控效果。

`TimerEnqueuePutService` 将定时消息放入时间轮和 `TimerLog`

不断扫描队列 `enqueuePutQueue`，取出 `TimerRequest`，并**批量**放入 `TimerLog`，再放入时间轮槽位。一批结束之后再操作下一批。

如果定时时间小于当前写 `TimerLog` 的时间，说明消息已经到期，直接加入到 `dequeuePutQueue`，准备投递到 `CommitLog`。

#### 3.2.2 定时消息投递

投递的步骤被分为三个任务：

1. 从时间轮中扫描到期的定时消息（偏移量）
2. 根据定时消息偏移量，到 `CommitLog` 中查询完整的消息体
3. 将查到的消息投递到 `CommitLog` 的目标 Topic

`TimerDequeueGetService` 扫描时间轮中到期的消息

这个线程的作用是：推进时间轮，将时间轮槽位对应的定时消息请求从时间轮和 `TimerLog` 中取出，加入到 `dequeueGetQueue` 中。

- 每 0.1s 执行一次，根据当前扫描时间轮的时间戳，从时间轮和 `TimerLog` 中查询出 `TimerRequest`，并分成定时请求和定时消息取消请求两类。
    
- 先批量将取消请求入队，等待处理完毕，再将定时消息请求入队，等待处理完毕。
    
- 该槽位的定时消息都处理完成后，推进时间轮扫描时间到下一槽位。
    

`TimerDequeueGetMessageService` 查询原始消息

这个线程的作用是：处理 `dequeueGetQueue` 中的 `TimerRequest`，根据索引在 `CommitLog` 中查出原始消息，放到 `dequeuePutQueue`。

- 从 `dequeueGetQueue` 中取出 `TimerRequest`
- 对取出的 `TimerRequst`，从 `CommitLog` 中查询原始消息
- 处理定时消息取消请求，查询出原始消息中要取消消息的 `UNIQ_KEY`，放入 `deleteUniqKeys` Set
- 处理普通定时消息请求
    - 如果 `DeleteUniqKeys` 中包含这个消息，则什么都不做（取消投递）
    - 否则将查出的原始消息放入 `TimerRequest`，然后将 `TimerRequest` 放入 `dequeuePutQueue`，准备投递到 `CommitLog`

`TimerDequeuePutMessageService` 投递定时消息

这个线程的作用是：将消息从 `dequeuePutQueue` 中取出，若已经到期，投递到 `CommitLog` 中

- 无限循环从 `dequeuePutQueue` 中取出 `TimerRequest`
- 将原始消息的 Topic 和 queueId 从消息属性中取出，用它们构造成一个新的消息
- 将消息投递到 `CommitLog`
- 如果投递失败，则需要等待{精确度 / 2}时间然后重新投递，必须保证消息投递成功。

### 3.3 其他设计

#### 3.3.1 定时消息文件的恢复

Broker 可能存在正常或者异常宕机。`TimerLog` 和 `TimerWheel` 都有做定时持久化，所以对于已经持久化的数据影响不大。

对于在内存中还未持久化的数据，可以通过 `TimerLog` 原封不动地还原出来。在 RIP-43 中设置了 `Checkpoint` 文件，以记录 `TimerLog` 中已经被 `TimerWheel` 记录的消息 offset。在重新启动时，将从该 `checkpoint` 记录的位置重新开始向后遍历 `TimerLog` 文件，并开始订正 `TimerWheel` 每一格中的头尾消息索引。

#### 3.3.2 随机读/PageCache 污染问题

在 `TimerLog` 和 `CommitLog` 中去查询定时消息，都不可避免发生随机读。若要避免这个情况，势必要对消息的写入作进一步优化：排序，或者按时间轮的定位情况写入多个文件。但是这样可能带来另一个问题：大量的随机写。

正如俗话说的，“读写难两全”。由于**定时消息对于写入更加敏感**，所以可以**牺牲一定的读性能来保障写入的速度**——当然，在性能测试中，该方案的读性能同样令人满意。

#### 3.3.3 另一种实现方案：RocksDB

RIP-43 中还提出了另一种任意时间定时消息的实现方案，即使用 RocksDB（一种 KV 本地存储）。

使用这种方式存储定时消息，将定时时间作为 Key，消息作为 Value，可以做到根据时间查询该时刻的所有定时消息。

![[rocketmq/_resources/延迟消费/f63b703ff3064ae75e8ead73ad1bb965_MD5.png]]

- Key：定时时间 + Topic + 消息 ID
    
- Value：定时消息数据
    

根据 Key 扫描 RocksDB 中的定时消息，如果到期则用生产-消费模式投递到 `CommitLog` 中。

---

这种方式的优点是：

1. 流程较简单。
2. 可以避免消息的滚动导致的写放大。
3. 一定程度上避免 pagecache 的污染。

缺点是：

1. 写入时需要排序，会额外消耗时间。
2. 在对 key 进行 compaction 的过程中可能会耗费额外的 CPU 资源。
3. 消息的检索需要消耗较多的计算资源。

最终没有选用这种方案的考量：

延时消息的写入速度与读取速度难以平衡。

1. 若 value 较大，大量消息的存储会导致 compaction 计算量较大。随着消息存储量的增加，**写入速度将逐渐变慢**。
2. 若采用 kv 分离以此保障写的速度，则**读消息的速度将受到较严重的影响**。

## 使用
### consumer

```java
package org.apache.rocketmq.example.schedule;  
  
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;  
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;  
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;  
import org.apache.rocketmq.common.message.MessageExt;  
  
public class TimerMessageConsumer {  
  
    //Note: TimerMessage is a new feature in version 5.0, so be sure to upgrade RocketMQ to version 5.0+ before using it.  
  
    public static final String CONSUMER_GROUP = "TimerMessageConsumerGroup";  
    public static final String DEFAULT_NAMESRVADDR = "127.0.0.1:9876";  
    public static final String TOPIC = "TimerTopic";  
  
    public static void main(String[] args) throws Exception {  
        // Instantiate message consumer  
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP);  
  
        // Uncomment the following line while debugging, namesrvAddr should be set to your local address  
        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);  
  
        // Subscribe topics       
         consumer.subscribe(TOPIC, "*");  
        // Register message listener  
        consumer.registerMessageListener((MessageListenerConcurrently) (messages, context) -> {  
            for (MessageExt message : messages) {  
                // Print approximate delay time period  
                System.out.printf("Receive message[msgId=%s %d  ms later]\n", message.getMsgId(),  
                    System.currentTimeMillis() - message.getBornTimestamp());  
            }  
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;  
        });  
        consumer.start();  
        //info:to see the time effect, run the consumer first , it will wait for the msg  
        //then start the producer   
         }  
}
```


### producer

```java
package org.apache.rocketmq.example.schedule;  
  
import java.nio.charset.StandardCharsets;  
import org.apache.rocketmq.client.producer.DefaultMQProducer;  
import org.apache.rocketmq.client.producer.SendResult;  
import org.apache.rocketmq.common.message.Message;  
  
public class TimerMessageProducer {  
  
    //Note: TimerMessage is a new feature in version 5.0, so be sure to upgrade RocketMQ to version 5.0+ before using it.  
  
    public static final String PRODUCER_GROUP = "TimerMessageProducerGroup";  
    public static final String DEFAULT_NAMESRVADDR = "127.0.0.1:9876";  
    public static final String TOPIC = "TimerTopic";  
  
    public static void main(String[] args) throws Exception {  
        // Instantiate a producer to send scheduled messages  
        DefaultMQProducer producer = new DefaultMQProducer(PRODUCER_GROUP);  
  
        // Uncomment the following line while debugging, namesrvAddr should be set to your local address  
      producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);  
  
        // Launch producer        producer.start();  
        int totalMessagesToSend = 10;  
        for (int i = 0; i < totalMessagesToSend; i++) {  
            Message message = new Message(TOPIC, ("Hello scheduled message " + i).getBytes(StandardCharsets.UTF_8));  
            // This message will be delivered to consumer 10 seconds later.  
            //message.setDelayTimeSec(10);            // The effect is the same as the above            // message.setDelayTimeMs(10_000L);            // Set the specific delivery time, and the effect is the same as the above            message.setDeliverTimeMs(System.currentTimeMillis() + 10_000L);  
            // Send the message  
            SendResult result = producer.send(message);  
            System.out.printf(result + "\n");  
        }  
  
        // Shutdown producer after use.  
        producer.shutdown();  
    }  
}
```